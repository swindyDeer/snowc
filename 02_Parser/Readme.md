# Part 2：解析简介 

 在我们的编译器编写过程的这一部分中，我将介绍解析器的基础知识。正如我在第一部分中提到的那样，解析器的工作是识别输入的语法和结构元素，并确保它们符合语言的语法。 

 我们已经有几种可以扫描的语言元素，即令牌 :

* 四个基本数学运算符：*，/，+和-
* 具有一个或多个0~9元素组成的十进制数

 现在让我们为解析器可以识别的语言定义一个语法 

## BNF

 如果您要处理计算机语言，则有时会遇到BNF的使用。我将在这里介绍足够多的BNF语法来表达我们想要识别的语法。 

 我们希望语法能用整数表达数学表达式。这是语法的BNF描述： 

```C#
expression: number
          | expression '*' expression
          | expression '/' expression
          | expression '+' expression
          | expression '-' expression
          ;

number:  T_INTLIT
    	 ;
```

 竖线将语法中的选项分开，因此上面的内容表示：

* 表达式可以只是一个数字，或者
* 一个表达式是两个由'*'标记分隔的表达式，或者
* 一个表达式是两个由'/'标记分隔的表达式，或者
* 一个表达式是两个由'+'标记分隔的表达式，或者
* 一个表达式是两个由'-'标记分隔的表达式
* 数字始终是T_INTLIT令牌  

 显然，语法的BNF定义是递归的：通过引用其他表达式来定义一个表达式。但是有一种方法可以“自下而上”地进行递归：当一个表达式原来是一个数字时，它总是一个T_INTLIT令牌，因此不是递归的 。

 在BNF中，我们说“表达式”和“数字”是非终结符，因为它们是由语法规则产生的。但是，T_INTLIT是终端符号，因为它没有任何规则定义。相反，它是该语言中已经被认可的令牌。同样，四个数学运算符是终端符号。 

## 递归下降解析

鉴于我们语言的语法是递归的，因此尝试递归解析它是有意义的。我们需要做的是读入令牌，然后向前看下一个令牌。根据下一个标记是什么，然后我们可以决定解析输入所需要的路径。这可能需要我们递归调用已被调用的函数。

在我们的例子中，任何表达式中的第一个标记都是数字，数学运算符可以跟在后面。之后，可能只有一个数字，或者可能是一个全新表达式的开始。我们如何递归解析呢？

我们可以编写如下的伪代码：

```C#
function expression() {
  扫描并检查第一个令牌是一个数字,如果不是则报错
  获取下一个令牌
  如果我们到达输入的末尾 返回
  其它情况, 调用 expression()
}
```

 让我们在输入2 + 3-5 T_EOF上运行此函数，其中T_EOF是反映输入结束的标记。我将对每个对expression（）的调用进行编号。 

```C#
expression0:
  扫描 2, 这是一个数字
  获取下一个令牌, +, 不是结束标志 T_EOF
  调用 expression()

    expression1:
      扫描 3, 这是一个数字
      获取下一个令牌, -, 不是结束标志 T_EOF
      调用 expression()

        expression2:
          扫描 5, 这是一个数字
          获取下一个令牌, 是结束标志T_EOF, 
		  因此返回 expression2

    返回 expression1
              
返回 expression0

```

 可以看到，该函数能够递归解析输入2 + 3-5 T_EOF 。

当然，我们对输入没有做任何事情，但这不是解析器的工作。解析器的工作是识别输入，并警告所有语法错误。输入的语义分析交给了编译器的其它部分，即理解并执行该输入的含义。

> 稍后，您将看到实际上并非如此。将语法分析和语义分析交织在一起通常是有意义的。 

## 抽象语法树

 要进行语义分析，我们需要解释输入的代码，或将其翻译为其他格式，例如汇编代码。在旅程的这一部分中，我们将为输入内容构建一个解释器。但是要到达那里，我们首先将输入转换为抽象语法树，也称为AST。

我强烈建议阅读AST的简短说明：

[用AST提升解析游戏的水平](https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff)

这篇文章写得很好，确实有助于解释AST的目的和结构。

AST中每个节点的结构在如下：

```C#
// AST 节点类型
enum {
  A_ADD, A_SUBTRACT, A_MULTIPLY, A_DIVIDE, A_INTLIT
};

// 抽象语法树结构
struct ASTnode {
  int op;                               // 将在此树上执行的“操作”
  struct ASTnode *left;                 // 左右子树
  struct ASTnode *right;
  int intvalue;                         // 对于A_INTLIT类型，是整数值
};
```

某些AST节点（例如具有op值A_ADD和A_SUBTRACT的AST节点）具有左右两个指向的子AST。稍后，我们将添加或减去子树的值。

或者，具有op值A_INTLIT的AST节点表示一个整数值。它没有子树后代，只有intvalue字段中的一个值。







